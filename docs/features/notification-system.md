# üîî Sistema de Notificaciones - MussikOn

## üìã **Resumen Ejecutivo**

El sistema de notificaciones de MussikOn es una implementaci√≥n avanzada que combina **notificaciones en tiempo real** con **persistencia local** para proporcionar una experiencia de usuario fluida y confiable. El sistema est√° completamente integrado con Socket.IO y AsyncStorage para garantizar que los usuarios nunca pierdan informaci√≥n importante.

---

## üéØ **Caracter√≠sticas Principales**

### ‚úÖ **Funcionalidades Implementadas**
- **Notificaciones en Tiempo Real** - Socket.IO para comunicaci√≥n instant√°nea
- **Persistencia Local** - AsyncStorage para notificaciones offline
- **Bot√≥n Flotante** - Indicador visual en header con contador
- **Pantalla Dedicada** - Gesti√≥n completa de notificaciones
- **Navegaci√≥n Contextual Inteligente** - Acceso directo seg√∫n tipo de notificaci√≥n
- **Marcado como Le√≠das** - Individual y masivo
- **Eliminaci√≥n** - Individual y masiva
- **Animaciones** - Feedback visual con animaciones suaves

---

## üèóÔ∏è **Arquitectura del Sistema**

### üì± **Frontend Components**

#### **1. FloatingNotificationButton**
```typescript
// src/components/notifications/FloatingNotificationButton.tsx
interface FloatingNotificationButtonProps {
  onPress: () => void;
}

const FloatingNotificationButton: React.FC<FloatingNotificationButtonProps> = ({ onPress }) => {
  const [unreadCount, setUnreadCount] = useState(0);
  const [pulseAnim] = useState(new Animated.Value(1));

  // Animaci√≥n de pulso cuando hay notificaciones
  const startPulseAnimation = () => {
    Animated.loop(
      Animated.sequence([
        Animated.timing(pulseAnim, {
          toValue: 1.1,
          duration: 1000,
          useNativeDriver: true,
        }),
        Animated.timing(pulseAnim, {
          toValue: 1,
          duration: 1000,
          useNativeDriver: true,
        }),
      ])
    ).start();
  };

  return (
    <Animated.View style={[styles.container, { transform: [{ scale: pulseAnim }] }]}>
      <TouchableOpacity style={styles.button} onPress={onPress}>
        <Ionicons name="notifications" size={18} color="#fff" />
        {unreadCount > 0 && (
          <View style={styles.badge}>
            <Text style={styles.badgeText}>
              {unreadCount > 99 ? '99+' : unreadCount.toString()}
            </Text>
          </View>
        )}
      </TouchableOpacity>
    </Animated.View>
  );
};
```

#### **2. NotificationsScreen**
```typescript
// src/screens/notifications/NotificationsScreen.tsx
const NotificationsScreen: React.FC = () => {
  const [notifications, setNotifications] = useState<Notification[]>([]);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    loadNotifications();
  }, []);

  const loadNotifications = async () => {
    try {
      const storedNotifications = await notificationService.getNotifications();
      setNotifications(storedNotifications);
    } catch (error) {
      console.error('Error al cargar notificaciones:', error);
    } finally {
      setLoading(false);
    }
  };

  const handleNotificationPress = (notification: Notification) => {
    // Marcar como le√≠da
    handleMarkAsRead(notification);
    
    // Navegaci√≥n inteligente seg√∫n tipo de notificaci√≥n
    if (notification.type === 'new_event_request') {
      // Para notificaciones de nuevas solicitudes, ir a la pantalla de solicitudes disponibles
      navigation.navigate('AvailableRequests');
    } else if (notification.eventId) {
      // Para otras notificaciones con eventId, navegar a detalles de la solicitud
      navigation.navigate('RequestDetail', { requestId: notification.eventId });
    } else {
      // Si no tiene eventId, ir a la lista de solicitudes
      navigation.navigate('MyRequestsList');
    }
  };

  return (
    <View style={styles.container}>
      <Header title="Notificaciones" />
      {loading ? (
        <LoadingSpinner />
      ) : (
        <FlatList
          data={notifications}
          keyExtractor={(item) => item.id}
          renderItem={({ item }) => (
            <NotificationItem
              notification={item}
              onPress={() => handleNotificationPress(item)}
              onDelete={() => deleteNotification(item.id)}
            />
          )}
        />
      )}
    </View>
  );
};
```

#### **3. NotificationItem**
```typescript
// src/components/notifications/NotificationItem.tsx
interface NotificationItemProps {
  notification: Notification;
  onPress: () => void;
  onDelete: () => void;
}

const NotificationItem: React.FC<NotificationItemProps> = ({
  notification,
  onPress,
  onDelete,
}) => {
  const { theme } = useTheme();

  const getNotificationIcon = () => {
    switch (notification.type) {
      case 'request_cancelled':
        return 'close-circle';
      case 'request_cancelled_by_musician':
        return 'musical-notes';
      case 'request_deleted':
        return 'trash';
      case 'musician_accepted':
        return 'checkmark-circle';
      case 'new_event_request':
        return 'add-circle';
      default:
        return 'notifications';
    }
  };

  const getNotificationColor = () => {
    switch (notification.type) {
      case 'request_cancelled':
      case 'request_cancelled_by_musician':
      case 'request_deleted':
        return theme.colors.error[500];
      case 'musician_accepted':
        return theme.colors.success[500];
      case 'new_event_request':
        return theme.colors.primary[500];
      default:
        return theme.colors.primary[500];
    }
  };

  return (
    <TouchableOpacity
      style={[
        styles.container,
        { backgroundColor: theme.colors.background.card },
        !notification.read && styles.unread,
      ]}
      onPress={onPress}
    >
      <View style={styles.iconContainer}>
        <Ionicons
          name={getNotificationIcon()}
          size={24}
          color={getNotificationColor()}
        />
      </View>
      <View style={styles.content}>
        <Text style={styles.title}>{notification.title}</Text>
        <Text style={styles.message}>{notification.message}</Text>
        <Text style={styles.timestamp}>
          {formatTimestamp(notification.timestamp)}
        </Text>
      </View>
      <TouchableOpacity style={styles.deleteButton} onPress={onDelete}>
        <Ionicons name="trash" size={20} color={theme.colors.text.secondary} />
      </TouchableOpacity>
    </TouchableOpacity>
  );
};
```

### üîå **Backend Services**

#### **1. NotificationService**
```typescript
// app_mussikon_express/src/services/NotificationService.ts
export class NotificationService {
  private io: any;

  constructor(io: any) {
    this.io = io;
  }

  async sendNewRequestNotification(event: Event) {
    try {
      // Buscar m√∫sicos disponibles
      const availableMusicians = await this.getAvailableMusicians();
      
      // Enviar notificaci√≥n a todos los m√∫sicos conectados
      availableMusicians.forEach(musician => {
        this.io.to(musician.socketId).emit('new_event_request', {
          eventId: event.id,
          event: event,
          timestamp: new Date().toISOString(),
        });
      });
    } catch (error) {
      console.error('Error enviando notificaci√≥n de nueva solicitud:', error);
    }
  }

  async sendRequestCancelledNotification(eventId: string, cancelledBy: string) {
    try {
      const event = await Event.findById(eventId);
      if (!event) return;
      
      // Enviar notificaci√≥n al m√∫sico asignado
      if (event.musicianId) {
        this.io.to(event.musicianId).emit('request_cancelled', {
          eventId: event.id,
          cancelledBy,
          event: event,
          timestamp: new Date().toISOString(),
        });
      }
    } catch (error) {
      console.error('Error enviando notificaci√≥n de cancelaci√≥n:', error);
    }
  }

  async sendRequestCompletedNotification(eventId: string, completedBy: string) {
    try {
      const event = await Event.findById(eventId);
      if (!event) return;
      
      // Enviar notificaci√≥n al organizador
      this.io.to(event.organizerId).emit('request_completed', {
        eventId: event.id,
        completedBy,
        event: event,
        timestamp: new Date().toISOString(),
      });
    } catch (error) {
      console.error('Error enviando notificaci√≥n de completado:', error);
    }
  }

  async sendMusicianAcceptedNotification(eventId: string, musicianId: string) {
    try {
      const event = await Event.findById(eventId);
      if (!event) return;
      
      // Enviar notificaci√≥n al organizador
      this.io.to(event.organizerId).emit('musician_accepted', {
        eventId: event.id,
        musicianId,
        event: event,
        timestamp: new Date().toISOString(),
      });
    } catch (error) {
      console.error('Error enviando notificaci√≥n de m√∫sico aceptado:', error);
    }
  }
}
```

---

## üîÑ **Flujo de Notificaciones**

### üì± **1. Recepci√≥n de Notificaci√≥n**
```mermaid
sequenceDiagram
    participant Backend
    participant Socket
    participant Frontend
    participant Storage

    Backend->>Socket: Emitir evento
    Socket->>Frontend: Recibir notificaci√≥n
    Frontend->>Storage: Guardar localmente
    Frontend->>Frontend: Actualizar UI
    Frontend->>Frontend: Mostrar animaci√≥n
```

### üîî **2. Tipos de Notificaciones**

#### **Eventos de Solicitudes**
- **`new_event_request`** - Nueva solicitud disponible para m√∫sicos
- **`request_cancelled`** - Solicitud cancelada por organizador
- **`request_cancelled_by_musician`** - Solicitud cancelada por m√∫sico
- **`request_deleted`** - Solicitud eliminada
- **`musician_accepted`** - M√∫sico acept√≥ la solicitud
- **`request_completed`** - Solicitud completada

#### **Estructura de Datos**
```typescript
interface Notification {
  id: string;
  userId: string;
  type: 'request_cancelled' | 'request_cancelled_by_musician' | 'request_deleted' | 'musician_accepted' | 'new_event_request';
  title: string;
  message: string;
  timestamp: string;
  read: boolean;
  eventId?: string;
  event?: any;
  data: any;
}
```

### üéØ **3. Navegaci√≥n Inteligente**

#### **L√≥gica de Navegaci√≥n**
```typescript
const handleNotificationPress = (notification: Notification) => {
  // Marcar como le√≠da
  handleMarkAsRead(notification);
  
  // Navegaci√≥n inteligente seg√∫n tipo de notificaci√≥n
  if (notification.type === 'new_event_request') {
    // Para notificaciones de nuevas solicitudes, ir a la pantalla de solicitudes disponibles
    navigation.navigate('AvailableRequests');
  } else if (notification.eventId) {
    // Para otras notificaciones con eventId, navegar a detalles de la solicitud
    navigation.navigate('RequestDetail', { requestId: notification.eventId });
  } else {
    // Si no tiene eventId, ir a la lista de solicitudes
    navigation.navigate('MyRequestsList');
  }
};
```

#### **Flujo por Tipo de Notificaci√≥n**
- **`new_event_request`** ‚Üí `AvailableRequestsScreen` (Solicitudes disponibles)
- **`musician_accepted`** ‚Üí `RequestDetail` (Detalles de solicitud)
- **`request_cancelled`** ‚Üí `RequestDetail` (Detalles de solicitud)
- **`request_completed`** ‚Üí `RequestDetail` (Detalles de solicitud)
- **Otros tipos** ‚Üí `MyRequestsList` (Lista general)

### üéØ **4. Estados de Notificaci√≥n**
- **`unread`** - No le√≠da (mostrar badge)
- **`read`** - Le√≠da (sin badge)
- **`deleted`** - Eliminada (no mostrar)

---

## üé® **UI/UX Features**

### üîî **Bot√≥n Flotante**
- **Posici√≥n**: Header, no intrusivo
- **Animaci√≥n**: Pulso cuando hay notificaciones nuevas
- **Badge**: Contador de no le√≠das
- **Accesibilidad**: Touch target adecuado

### üì± **Pantalla de Notificaciones**
- **Lista**: Scroll infinito con FlatList
- **Estados**: Loading, empty, error
- **Acciones**: Marcar como le√≠da, eliminar
- **Navegaci√≥n**: Ir a detalles de solicitud o solicitudes disponibles

### üé® **Dise√±o Visual**
- **Iconos**: Espec√≠ficos por tipo de notificaci√≥n
- **Colores**: Consistentes con el tema
- **Tipograf√≠a**: Jerarqu√≠a clara
- **Espaciado**: Respeta guidelines de dise√±o

---

## üîß **Configuraci√≥n y Setup**

### üì± **Frontend Setup**
```typescript
// src/App.tsx
import { NotificationProvider } from './contexts/NotificationContext';

const App = () => {
  return (
    <NotificationProvider>
      <SocketProvider>
        <NavigationContainer>
          {/* App content */}
        </NavigationContainer>
      </SocketProvider>
    </NotificationProvider>
  );
};
```

### üîå **Backend Setup**
```typescript
// app_mussikon_express/index.ts
import { NotificationService } from './src/services/NotificationService';

const server = http.createServer(app);
const io = initializeSocket(server, users);

// Inicializar servicio de notificaciones
const notificationService = new NotificationService(io);
```

---

## üöÄ **Optimizaciones Implementadas**

### ‚ö° **Performance**
- **Lazy Loading**: Notificaciones cargadas bajo demanda
- **Cach√© Local**: AsyncStorage para notificaciones offline
- **Optimizaci√≥n de Lista**: FlatList con optimizaciones
- **Debounce**: Evitar m√∫ltiples llamadas simult√°neas

### üîÑ **Reconexi√≥n Autom√°tica**
- **Socket.IO**: Reconexi√≥n autom√°tica en p√©rdida de conexi√≥n
- **Estado Persistente**: Mantener notificaciones durante reconexi√≥n
- **Sincronizaci√≥n**: Sincronizar estado con servidor al reconectar

### üéØ **Experiencia de Usuario**
- **Feedback T√°ctil**: Vibraci√≥n en iOS al interactuar
- **Animaciones Suaves**: Transiciones fluidas
- **Estados Claros**: Loading, error, empty states
- **Navegaci√≥n Intuitiva**: Flujo l√≥gico seg√∫n tipo de notificaci√≥n

---

## üìä **M√©tricas y Analytics**

### üìà **Eventos Rastreados**
- **Notificaci√≥n Recibida**: Tipo, timestamp, usuario
- **Notificaci√≥n Abierta**: Tipo, tiempo desde recepci√≥n
- **Navegaci√≥n**: Pantalla de destino
- **Acciones**: Aceptar, rechazar, eliminar

### üìä **KPIs Principales**
- **Tiempo de Respuesta**: Desde notificaci√≥n hasta acci√≥n
- **Tasa de Apertura**: Porcentaje de notificaciones abiertas
- **Tasa de Conversi√≥n**: Notificaciones que llevan a acci√≥n
- **Satisfacci√≥n**: Feedback del usuario

---

## üîÆ **Roadmap y Mejoras Futuras**

### üöÄ **Pr√≥ximas Funcionalidades**
- **Notificaciones Push**: Integraci√≥n con FCM/APNS
- **Filtros Avanzados**: Por tipo, fecha, estado
- **B√∫squeda**: Buscar en notificaciones
- **Categorizaci√≥n**: Agrupar por tipo de evento

### üé® **Mejoras de UI/UX**
- **Modo Oscuro**: Soporte completo para tema oscuro
- **Animaciones**: Transiciones m√°s fluidas
- **Accesibilidad**: Mejor soporte para lectores de pantalla
- **Personalizaci√≥n**: Configuraci√≥n de notificaciones por usuario

### üîß **Mejoras T√©cnicas**
- **WebSockets**: Migraci√≥n a WebSockets nativos
- **Compresi√≥n**: Comprimir datos de notificaciones
- **Cach√© Inteligente**: Estrategias de cach√© avanzadas
- **Testing**: Tests unitarios y de integraci√≥n

---

## üìö **Referencias y Recursos**

### üìñ **Documentaci√≥n Relacionada**
- [Sistema de Solicitudes](./solicitud-musico-flujo-musico.md)
- [Pantalla de Solicitudes Disponibles](./available-requests-screen.md)
- [Navegaci√≥n Inteligente](./navigation-system.md)
- [Socket.IO Integration](./socket-io-integration.md)

### üõ†Ô∏è **Herramientas Utilizadas**
- **Socket.IO**: Comunicaci√≥n en tiempo real
- **AsyncStorage**: Persistencia local
- **React Navigation**: Navegaci√≥n entre pantallas
- **Expo Haptics**: Feedback t√°ctil

---

## ‚úÖ **Estado de Implementaci√≥n**

### üéØ **Completado (100%)**
- ‚úÖ **Sistema de Notificaciones**: Funcionalidad completa
- ‚úÖ **Navegaci√≥n Inteligente**: Seg√∫n tipo de notificaci√≥n
- ‚úÖ **Pantalla de Solicitudes Disponibles**: Nueva funcionalidad
- ‚úÖ **Integraci√≥n Socket.IO**: Tiempo real
- ‚úÖ **Persistencia Local**: AsyncStorage
- ‚úÖ **UI/UX Moderna**: Dise√±o consistente

### üîÑ **En Desarrollo**
- üîÑ **Notificaciones Push**: Integraci√≥n con FCM
- üîÑ **Filtros Avanzados**: Por tipo y fecha
- üîÑ **Analytics**: M√©tricas detalladas

### üìã **Pendiente**
- ‚è≥ **Modo Offline**: Sincronizaci√≥n completa
- ‚è≥ **Testing**: Tests automatizados
- ‚è≥ **Performance**: Optimizaciones avanzadas 